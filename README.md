# Transactional outbox pattern with MongoDB and k8s


<p align="center">
<a href="https://nodejs.org/en/"><img src="https://img.shields.io/badge/node--js-v16.x.x-green" alt="node-js" /></a>
<a href="https://nestjs.com/"><img src="https://img.shields.io/badge/nestjs-v8.x.x-red" alt="nestjs" /></a>
<a href="https://www.npmjs.com/package/typescript"><img src="https://img.shields.io/badge/typescript-v4.x.x-blue" alt="typescript" /></a>
<a href="https://www.npmjs.com/package/mongoose"><img src="https://img.shields.io/badge/mongoose-v6.x.x-green" alt="mongoose" /></a> <a href="https://www.docker.com/"><img src="https://img.shields.io/badge/docker-v20.x.x-blue" alt="docker" /></a> <a href="https://kubernetes.io/docs/home/"><img src="https://img.shields.io/badge/k8s-v1.22.x-blue" alt="docker" /></a> <a href="https://minikube.sigs.k8s.io/docs/"><img src="https://img.shields.io/badge/minikube-v1.22.x-blue" alt="docker" /></a>
<a href="https://choosealicense.com/licenses/mit/" target="_blank"><img src="https://img.shields.io/badge/license-MIT-green" alt="Package License" ></a>
</p>

## Description

This project implements the transactional outbox pattern for microservices running in a kubernetes cluster, using [MongoDB change streams](https://www.mongodb.com/docs/v5.0/changeStreams/#std-label-change-stream-resume-token) and [Google Pub Sub](https://cloud.google.com/pubsub/docs/overview) as message broker. The project consists of:

- Publisher: a service that emits events when the  `"/greeting"` endpoint receives a `POST` request with the following body `{ "text": "<your hello message>" }`
- Subscriber: a service that listens to the `created.greeting` event and stores it in the database
- Database: MongoDB instance configured to run as a replica set to listen to change streams
- Message broker: Pub-Sub fake used as message broker

## Transactional outbox pattern

The transactional outbox pattern is a mechanism that allows to reliably perform write operation to a database and emit events. In order to ensure consistency, a service needs to update the database and send events atomically and ensure that events are sent in order.
This is achieved by storing events in a dedicated outbox table as part of the same transaction that updates the database and triggers the event. Once the transaction completes, another process is in charge of fetching the events and sending them to the message broker. The possible ways to notify the relay process that there are outstanding events are:

- Database polling
- Transaction log polling

### Database polling

Database polling consists in fetching the outbox table frequently to get the outstanding events and publish them.

#### Pros

- Easy to implement and understand

#### Cons

- Wastes resources as it could perfom useless queries when there are no event to publish

### Transaction log polling

The alternative to database polling is transactional log polling which consists in the relay service to listen events emitted by the database when a transaction completes successfully and convert them to events that are sent to the message broker.

#### Pros

- Works well at scale
- Does not waste resources by making unnecessary queries

#### Cons

- Can be a little bit more difficult to understand and implement compared to database polling

## Solution description

The `publisher` service uses the transactional outbox pattern to publish events. As change streams send events to all listeners,  every instance of the `publisher` service is idenfied by the pod name generated by the kubernetes cluster which is then used to 'sign' an event. The idenfier is then used in the [pipeline](https://www.mongodb.com/docs/manual/changeStreams/#modify-change-stream-output) passed to the change stream listener to filter events emitted by the database, so that only the service that produced an event can send it to the message broker.  

## How to run the project

You can use [minikube](https://minikube.sigs.k8s.io/docs/) (or any alternative like [k3s](https://k3s.io/)) to easily create a kubernetes cluster on your machine

To send requests to the `publisher` service running in the local k8s cluster you'll need to configure [ingress](https://kubernetes.github.io/ingress-nginx/) depending on which local cluster solution you choose

The project defines a `skaffold.yaml` file that allows to easily create all the kubernetes objects using [skaffold](https://skaffold.dev/) and the configuration files defined in the `./infra` directory by running the command:

```text
# Runs the project in watch mode
skaffold dev
```

or

```text
skaffold run
```

## License

[MIT](https://choosealicense.com/licenses/mit/)
